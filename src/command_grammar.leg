%{
	#define YYSTYPE unsigned long
	#include <stdlib.h>
	#include <stdbool.h>

	////////// ZU_STACK_STATE //////////
	typedef char jf_zu_stack_state;

	#define JF_ZU_STACK_SUCCESS		0
	#define JF_ZU_STACK_CLEAR		1
	#define JF_ZU_STACK_ATOMS		2
	#define JF_ZU_STACK_FOLDER		3
	#define JF_ZU_STACK_RECURSIVE	4
	#define JF_ZU_STACK_FAIL_FOLDER	-1
	#define JF_ZU_STACK_FAIL_MATCH	-2

	#define JF_ZU_STACK_IS_FAIL(state)	((state) < 0)
	////////////////////////////////////


	////////// YY_CTX //////////
	// forward declartion wrt PEG generated code
	typedef struct _yycontext yycontext;

	#define YY_CTX_LOCAL
	#define YY_CTX_MEMBERS					\
		size_t *zu_stack;					\
		size_t zu_stack_size;				\
		size_t zu_stack_used;				\
		jf_zu_stack_state zu_stack_state;
	////////////////////////////


	////////// FUNCTION PROTOTYPES //////////
	jf_zu_stack_state yy_zu_stack_get_state(const yycontext *ctx);

	static void yy_zu_stack_init(yycontext *ctx);
	static size_t yy_zu_stack_pop(yycontext *ctx);
	static void yy_zu_stack_push(yycontext *ctx, const size_t n);
	static void yy_zu_stack_push_range(yycontext *ctx, size_t l, const size_t r);
	static void yy_zu_stack_finalize(yycontext *ctx, const bool parse_ok);
	/////////////////////////////////////////
%}


Start = ws*						@{ yy_zu_stack_init(yy); } # runs every match: that means once
	( ".." ws*					{ jf_menu_dotdot(); }
	| "r" ws+ @{ yy->zu_stack_state = JF_ZU_STACK_RECURSIVE; printf("recursive "); } Selector ws*
	| "s" ws+ < string >		{ printf("search \"%s\"\n", yytext); }
	| 'q' ws*					{ jf_menu_quit(); }
	| Selector ws*
	) ~ { yy_zu_stack_finalize(yy, false); } { yy_zu_stack_finalize(yy, true); } eol
Selector = '*'					{ yy_zu_stack_push_range(yy, 1, jf_menu_child_count()); }
	| Items
Items = Atom ws* ',' ws* Items
	| Atom
Atom = l:num ws* '-' ws* r:num	{ yy_zu_stack_push_range(yy, l, r); }
	| n:num						{ yy_zu_stack_push(yy, n); }
num = < [0-9]+ >				{ $$ = strtoul(yytext, NULL, 10); }
ws = [ \t]
string = [^\n\r]+
eol = '\n' | '\r\n' | '\r'


%%
	jf_zu_stack_state yy_zu_stack_get_state(const yycontext *ctx)
	{
		return ctx->zu_stack_state;
	}


	static void yy_zu_stack_init(yycontext *ctx)
	{
		ctx->zu_stack = malloc(20 * sizeof(size_t));
		ctx->zu_stack_size = 20;
		ctx->zu_stack_used = 0;
		ctx->zu_stack_state = JF_ZU_STACK_CLEAR;
	}


	static size_t yy_zu_stack_pop(yycontext *ctx)
	{
		return ctx->zu_stack_used > 0 ? ctx->zu_stack[--ctx->zu_stack_used] : 0;
	}


	static void yy_zu_stack_push(yycontext *ctx, const size_t n)
	{
		bool is_folder;

		// no-op on fail state
		if (JF_ZU_STACK_IS_FAIL(ctx->zu_stack_state)) {
			return;
		}

		is_folder = jf_menu_child_is_folder(n);

		// folder change commands can only target one folder and no other items
		// unless recursive
		if (is_folder && ! (ctx->zu_stack_state == JF_ZU_STACK_CLEAR
							|| ctx->zu_stack_state == JF_ZU_STACK_RECURSIVE)) {
			ctx->zu_stack_state = JF_ZU_STACK_FAIL_FOLDER;
			return;
		}

		// check space
		if (ctx->zu_stack_size == ctx->zu_stack_used) {
			size_t *tmp = realloc(ctx->zu_stack, ctx->zu_stack_size * 2 * sizeof(size_t));
			if (tmp == NULL) {
				return;
			}
			ctx->zu_stack = tmp;
		}

		// actual push
		ctx->zu_stack[ctx->zu_stack_used++] = n;
		printf("%zu ", n);

		// check state, preserving recursiveness
		if (ctx->zu_stack_state != JF_ZU_STACK_RECURSIVE) {
			ctx->zu_stack_state = is_folder ? JF_ZU_STACK_FOLDER : JF_ZU_STACK_ATOMS;
		}
	}


	static void yy_zu_stack_push_range(yycontext *ctx, size_t l, const size_t r)
	{
		int step = l <= r ? 1 : -1;
		while (true) {
			yy_zu_stack_push(ctx, l);
			l += step;
			if (l == r) break;
		}
	}


	static void yy_zu_stack_finalize(yycontext *ctx, const bool parse_ok)
	{
		size_t n;

		if (parse_ok == false) {
			free(ctx->zu_stack);
			ctx->zu_stack_state = JF_ZU_STACK_FAIL_MATCH;
			return;
		}

		if (ctx->zu_stack_state == JF_ZU_STACK_FAIL_FOLDER) {
			free(ctx->zu_stack);
			return;
		}

		while ((n = yy_zu_stack_pop(ctx)) != 0) {
			jf_menu_child_push(n);
		}
		free(ctx->zu_stack);
		ctx->zu_stack_state = JF_ZU_STACK_SUCCESS;
	}
